/* http://prismjs.com/download.html?themes=prism-okaidia&languages=markup+css+css-extras+clike+javascript+java+php+php-extras+c+cpp+python+csharp+aspnet */
self = typeof window != "undefined" ? window : typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope ? self : {}; var Prism = function () { var e = /\blang(?:uage)?-(?!\*)(\w+)\b/i, t = self.Prism = { util: { encode: function (e) { return e instanceof n ? new n(e.type, t.util.encode(e.content), e.alias) : t.util.type(e) === "Array" ? e.map(t.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ") }, type: function (e) { return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1] }, clone: function (e) { var n = t.util.type(e); switch (n) { case "Object": var r = {}; for (var i in e) e.hasOwnProperty(i) && (r[i] = t.util.clone(e[i])); return r; case "Array": return e.slice() } return e } }, languages: { extend: function (e, n) { var r = t.util.clone(t.languages[e]); for (var i in n) r[i] = n[i]; return r }, insertBefore: function (e, n, r, i) { i = i || t.languages; var s = i[e]; if (arguments.length == 2) { r = arguments[1]; for (var o in r) r.hasOwnProperty(o) && (s[o] = r[o]); return s } var u = {}; for (var a in s) if (s.hasOwnProperty(a)) { if (a == n) for (var o in r) r.hasOwnProperty(o) && (u[o] = r[o]); u[a] = s[a] } t.languages.DFS(t.languages, function (t, n) { n === i[e] && t != e && (this[t] = u) }); return i[e] = u }, DFS: function (e, n, r) { for (var i in e) if (e.hasOwnProperty(i)) { n.call(e, i, e[i], r || i); t.util.type(e[i]) === "Object" ? t.languages.DFS(e[i], n) : t.util.type(e[i]) === "Array" && t.languages.DFS(e[i], n, i) } } }, highlightAll: function (e, n) { var r = document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'); for (var i = 0, s; s = r[i++];) t.highlightElement(s, e === !0, n) }, highlightElement: function (r, i, s) { var o, u, a = r; while (a && !e.test(a.className)) a = a.parentNode; if (a) { o = (a.className.match(e) || [, ""])[1]; u = t.languages[o] } if (!u) return; r.className = r.className.replace(e, "").replace(/\s+/g, " ") + " language-" + o; a = r.parentNode; /pre/i.test(a.nodeName) && (a.className = a.className.replace(e, "").replace(/\s+/g, " ") + " language-" + o); var f = r.textContent; if (!f) return; var l = { element: r, language: o, grammar: u, code: f }; t.hooks.run("before-highlight", l); if (i && self.Worker) { var c = new Worker(t.filename); c.onmessage = function (e) { l.highlightedCode = n.stringify(JSON.parse(e.data), o); t.hooks.run("before-insert", l); l.element.innerHTML = l.highlightedCode; s && s.call(l.element); t.hooks.run("after-highlight", l) }; c.postMessage(JSON.stringify({ language: l.language, code: l.code })) } else { l.highlightedCode = t.highlight(l.code, l.grammar, l.language); t.hooks.run("before-insert", l); l.element.innerHTML = l.highlightedCode; s && s.call(r); t.hooks.run("after-highlight", l) } }, highlight: function (e, r, i) { var s = t.tokenize(e, r); return n.stringify(t.util.encode(s), i) }, tokenize: function (e, n, r) { var i = t.Token, s = [e], o = n.rest; if (o) { for (var u in o) n[u] = o[u]; delete n.rest }e: for (var u in n) { if (!n.hasOwnProperty(u) || !n[u]) continue; var a = n[u]; a = t.util.type(a) === "Array" ? a : [a]; for (var f = 0; f < a.length; ++f) { var l = a[f], c = l.inside, h = !!l.lookbehind, p = 0, d = l.alias; l = l.pattern || l; for (var v = 0; v < s.length; v++) { var m = s[v]; if (s.length > e.length) break e; if (m instanceof i) continue; l.lastIndex = 0; var g = l.exec(m); if (g) { h && (p = g[1].length); var y = g.index - 1 + p, g = g[0].slice(p), b = g.length, w = y + b, E = m.slice(0, y + 1), S = m.slice(w + 1), x = [v, 1]; E && x.push(E); var T = new i(u, c ? t.tokenize(g, c) : g, d); x.push(T); S && x.push(S); Array.prototype.splice.apply(s, x) } } } } return s }, hooks: { all: {}, add: function (e, n) { var r = t.hooks.all; r[e] = r[e] || []; r[e].push(n) }, run: function (e, n) { var r = t.hooks.all[e]; if (!r || !r.length) return; for (var i = 0, s; s = r[i++];) s(n) } } }, n = t.Token = function (e, t, n) { this.type = e; this.content = t; this.alias = n }; n.stringify = function (e, r, i) { if (typeof e == "string") return e; if (Object.prototype.toString.call(e) == "[object Array]") return e.map(function (t) { return n.stringify(t, r, e) }).join(""); var s = { type: e.type, content: n.stringify(e.content, r, i), tag: "span", classes: ["token", e.type], attributes: {}, language: r, parent: i }; s.type == "comment" && (s.attributes.spellcheck = "true"); if (e.alias) { var o = t.util.type(e.alias) === "Array" ? e.alias : [e.alias]; Array.prototype.push.apply(s.classes, o) } t.hooks.run("wrap", s); var u = ""; for (var a in s.attributes) u += a + '="' + (s.attributes[a] || "") + '"'; return "<" + s.tag + ' class="' + s.classes.join(" ") + '" ' + u + ">" + s.content + "</" + s.tag + ">" }; if (!self.document) { if (!self.addEventListener) return self.Prism; self.addEventListener("message", function (e) { var n = JSON.parse(e.data), r = n.language, i = n.code; self.postMessage(JSON.stringify(t.util.encode(t.tokenize(i, t.languages[r])))); self.close() }, !1); return self.Prism } var r = document.getElementsByTagName("script"); r = r[r.length - 1]; if (r) { t.filename = r.src; document.addEventListener && !r.hasAttribute("data-manual") && document.addEventListener("DOMContentLoaded", t.highlightAll) } return self.Prism }(); typeof module != "undefined" && module.exports && (module.exports = Prism);;
Prism.languages.markup = { comment: /<!--[\w\W]*?-->/g, prolog: /<\?.+?\?>/, doctype: /<!DOCTYPE.+?>/, cdata: /<!\[CDATA\[[\w\W]*?]]>/i, tag: { pattern: /<\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|[^\s'">=]+))?\s*)*\/?>/gi, inside: { tag: { pattern: /^<\/?[\w:-]+/i, inside: { punctuation: /^<\/?/, namespace: /^[\w-]+?:/ } }, "attr-value": { pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi, inside: { punctuation: /=|>|"/g } }, punctuation: /\/?>/g, "attr-name": { pattern: /[\w:-]+/g, inside: { namespace: /^[\w-]+?:/ } } } }, entity: /\&#?[\da-z]{1,8};/gi }, Prism.hooks.add("wrap", function (t) { "entity" === t.type && (t.attributes.title = t.content.replace(/&amp;/, "&")) });;
Prism.languages.css = { comment: /\/\*[\w\W]*?\*\//g, atrule: { pattern: /@[\w-]+?.*?(;|(?=\s*{))/gi, inside: { punctuation: /[;:]/g } }, url: /url\((["']?).*?\1\)/gi, selector: /[^\{\}\s][^\{\};]*(?=\s*\{)/g, property: /(\b|\B)[\w-]+(?=\s*:)/gi, string: /("|')(\\?.)*?\1/g, important: /\B!important\b/gi, punctuation: /[\{\};:]/g, "function": /[-a-z0-9]+(?=\()/gi }, Prism.languages.markup && (Prism.languages.insertBefore("markup", "tag", { style: { pattern: /<style[\w\W]*?>[\w\W]*?<\/style>/gi, inside: { tag: { pattern: /<style[\w\W]*?>|<\/style>/gi, inside: Prism.languages.markup.tag.inside }, rest: Prism.languages.css }, alias: "language-css" } }), Prism.languages.insertBefore("inside", "attr-value", { "style-attr": { pattern: /\s*style=("|').+?\1/gi, inside: { "attr-name": { pattern: /^\s*style/gi, inside: Prism.languages.markup.tag.inside }, punctuation: /^\s*=\s*['"]|['"]\s*$/, "attr-value": { pattern: /.+/gi, inside: Prism.languages.css } }, alias: "language-css" } }, Prism.languages.markup.tag));;
Prism.languages.css.selector = { pattern: /[^\{\}\s][^\{\}]*(?=\s*\{)/g, inside: { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/g, "pseudo-class": /:[-\w]+(?:\(.*\))?/g, "class": /\.[-:\.\w]+/g, id: /#[-:\.\w]+/g } }, Prism.languages.insertBefore("css", "ignore", { hexcode: /#[\da-f]{3,6}/gi, entity: /\\[\da-f]{1,8}/gi, number: /[\d%\.]+/g });;
Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\w\W]*?\*\//g, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*?(\r?\n|$)/g, lookbehind: !0 }], string: /("|')(\\?.)*?\1/g, "class-name": { pattern: /((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/gi, lookbehind: !0, inside: { punctuation: /(\.|\\)/ } }, keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/g, "boolean": /\b(true|false)\b/g, "function": { pattern: /[a-z0-9_]+\(/gi, inside: { punctuation: /\(/ } }, number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g, operator: /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\|?\||\?|\*|\/|\~|\^|\%/g, ignore: /&(lt|gt|amp);/gi, punctuation: /[{}[\];(),.:]/g };;
Prism.languages.javascript = Prism.languages.extend("clike", { keyword: /\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/g, number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?|NaN|-?Infinity)\b/g }), Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g, lookbehind: !0 } }), Prism.languages.markup && Prism.languages.insertBefore("markup", "tag", { script: { pattern: /<script[\w\W]*?>[\w\W]*?<\/script>/gi, inside: { tag: { pattern: /<script[\w\W]*?>|<\/script>/gi, inside: Prism.languages.markup.tag.inside }, rest: Prism.languages.javascript }, alias: "language-javascript" } });;
Prism.languages.java = Prism.languages.extend("clike", { keyword: /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/g, number: /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+[e]?[\d]*[df]\b|\W\d*\.?\d+\b/gi, operator: { pattern: /(^|[^\.])(?:\+=|\+\+?|-=|--?|!=?|<{1,2}=?|>{1,3}=?|==?|&=|&&?|\|=|\|\|?|\?|\*=?|\/=?|%=?|\^=?|:|~)/gm, lookbehind: !0 } });;
Prism.languages.php = Prism.languages.extend("clike", { keyword: /\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/gi, constant: /\b[A-Z0-9_]{2,}\b/g, comment: { pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|(^|[^:])(\/\/|#).*?(\r?\n|$))/g, lookbehind: !0 } }), Prism.languages.insertBefore("php", "keyword", { delimiter: /(\?>|<\?php|<\?)/gi, variable: /(\$\w+)\b/gi, "package": { pattern: /(\\|namespace\s+|use\s+)[\w\\]+/g, lookbehind: !0, inside: { punctuation: /\\/ } } }), Prism.languages.insertBefore("php", "operator", { property: { pattern: /(->)[\w]+/g, lookbehind: !0 } }), Prism.languages.markup && (Prism.hooks.add("before-highlight", function (e) { "php" === e.language && (e.tokenStack = [], e.backupCode = e.code, e.code = e.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/gi, function (n) { return e.tokenStack.push(n), "{{{PHP" + e.tokenStack.length + "}}}" })) }), Prism.hooks.add("before-insert", function (e) { "php" === e.language && (e.code = e.backupCode, delete e.backupCode) }), Prism.hooks.add("after-highlight", function (e) { if ("php" === e.language) { for (var n, a = 0; n = e.tokenStack[a]; a++) e.highlightedCode = e.highlightedCode.replace("{{{PHP" + (a + 1) + "}}}", Prism.highlight(n, e.grammar, "php")); e.element.innerHTML = e.highlightedCode } }), Prism.hooks.add("wrap", function (e) { "php" === e.language && "markup" === e.type && (e.content = e.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g, '<span class="token php">$1</span>')) }), Prism.languages.insertBefore("php", "comment", { markup: { pattern: /<[^?]\/?(.*?)>/g, inside: Prism.languages.markup }, php: /\{\{\{PHP[0-9]+\}\}\}/g }));;
Prism.languages.insertBefore("php", "variable", { "this": /\$this/g, global: /\$_?(GLOBALS|SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/g, scope: { pattern: /\b[\w\\]+::/g, inside: { keyword: /(static|self|parent)/, punctuation: /(::|\\)/ } } });;
Prism.languages.c = Prism.languages.extend("clike", { string: /("|')([^\n\\\1]|\\.|\\\r*\n)*?\1/g, keyword: /\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/g, operator: /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\//g }), Prism.languages.insertBefore("c", "string", { property: { pattern: /((^|\n)\s*)#\s*[a-z]+([^\n\\]|\\.|\\\r*\n)*/gi, lookbehind: !0, inside: { string: { pattern: /(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/g, lookbehind: !0 } } } }), delete Prism.languages.c["class-name"], delete Prism.languages.c["boolean"];;
Prism.languages.cpp = Prism.languages.extend("c", { keyword: /\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|delete\[\]|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|new\[\]|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/g, "boolean": /\b(true|false)\b/g, operator: /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/g }), Prism.languages.insertBefore("cpp", "keyword", { "class-name": { pattern: /(class\s+)[a-z0-9_]+/gi, lookbehind: !0 } });;
Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*?(\r?\n|$)/g, lookbehind: !0 }, string: /"""[\s\S]+?"""|("|')(\\?.)*?\1/g, keyword: /\b(as|assert|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/g, "boolean": /\b(True|False)\b/g, number: /\b-?(0x)?\d*\.?[\da-f]+\b/g, operator: /[-+]{1,2}|=?&lt;|=?&gt;|!|={1,2}|(&){1,2}|(&amp;){1,2}|\|?\||\?|\*|\/|~|\^|%|\b(or|and|not)\b/g, ignore: /&(lt|gt|amp);/gi, punctuation: /[{}[\];(),.:]/g };;
Prism.languages.csharp = Prism.languages.extend("clike", { keyword: /\b(abstract|as|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/g, string: /@?("|')(\\?.)*?\1/g, preprocessor: /^\s*#.*/gm, number: /\b-?(0x)?\d*\.?\d+\b/g });;
Prism.languages.aspnet = Prism.languages.extend("markup", { "page-directive tag": { pattern: /<%\s*@.*%>/gi, inside: { "page-directive tag": /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master|MasterType|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/gi, rest: Prism.languages.markup.tag.inside } }, "directive tag": { pattern: /<%.*%>/gi, inside: { "directive tag": /<%\s*?[$=%#:]{0,2}|%>/gi, rest: Prism.languages.csharp } } }), Prism.languages.insertBefore("inside", "punctuation", { "directive tag": Prism.languages.aspnet["directive tag"] }, Prism.languages.aspnet.tag.inside["attr-value"]), Prism.languages.insertBefore("aspnet", "comment", { "asp comment": /<%--[\w\W]*?--%>/g }), Prism.languages.insertBefore("aspnet", Prism.languages.javascript ? "script" : "tag", { "asp script": { pattern: /<script(?=.*runat=['"]?server['"]?)[\w\W]*?>[\w\W]*?<\/script>/gi, inside: { tag: { pattern: /<\/?script\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?>/gi, inside: Prism.languages.aspnet.tag.inside }, rest: Prism.languages.csharp || {} } } }), Prism.languages.aspnet.style && (Prism.languages.aspnet.style.inside.tag.pattern = /<\/?style\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?>/gi, Prism.languages.aspnet.style.inside.tag.inside = Prism.languages.aspnet.tag.inside), Prism.languages.aspnet.script && (Prism.languages.aspnet.script.inside.tag.pattern = Prism.languages.aspnet["asp script"].inside.tag.pattern, Prism.languages.aspnet.script.inside.tag.inside = Prism.languages.aspnet.tag.inside);;